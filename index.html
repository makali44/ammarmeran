<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kick Auto Commenter x3</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: #f0f2f5;
      padding: 30px;
      color: #333;
    }
    h2 {
      text-align: center;
      color: #2c3e50;
    }
    .container {
      max-width: 600px;
      margin: 30px auto;
      background: white;
      padding: 20px 30px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    textarea, input {
      width: 100%;
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 14px;
      box-sizing: border-box;
      resize: none;
      overflow-y: hidden;
    }
    button {
      padding: 10px 20px;
      margin: 10px 5px 0 0;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s ease-in-out;
    }
    button:hover {
      opacity: 0.9;
    }
    .startBtn {
      background-color: #2ecc71;
      color: white;
    }
    .stopBtn {
      background-color: #e74c3c;
      color: white;
    }
    .log {
      background: #f9f9f9;
      padding: 10px;
      margin-top: 15px;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 13px;
    }
  </style>
</head>
<body>
  

  <h2>üéØ Freeze </h2>

  <!-- 3 ŸÜÿ≥ÿÆ ŸÖÿ≥ÿ™ŸÇŸÑÿ© -->
  <div id="commenter1" class="container"></div>
  <div id="commenter2" class="container"></div>
  <div id="commenter3" class="container"></div>


  <script>
    function createCommenter(containerId, instanceId) {
      const container = document.getElementById(containerId);

      container.innerHTML = `
        <h3> ${instanceId}</h3>

        <label>üé´ Bearer Tokens (Ÿàÿßÿ≠ÿØ ÿ®ŸÉŸÑ ÿ≥ÿ∑ÿ±)</label>
        <textarea id="tokens_${instanceId}" rows="1" placeholder="...">Bearer 125861420|24bcLlEZwXnv22SzKIjP2g8oG74dnhCnuOV450cG
Bearer 125754317|sDTNU3UZPM8v0Y3MQqumTlZgBIvJ8m5ZltLQsDeX
Bearer 125353058|PzCxtv49vny460Jxa5wuLatYwcdZn0sa7KCWR7Ut
Bearer 125966654|vXhoU8tLmxARJOQfpt0gosSXBpVhSGkMdwxSPKdh
Bearer 125963774|d5AGXB4zwNdAEa3st6etmLAEGjjac7TDuBKy45dx
Bearer 125359592|YhMasda3QokNz3ujvTb8LqtgNi6MDjLYxUQrMegh
Bearer 125356381|NpeSSj4lLMPitWUeVMUimAe7gr8S4JjCbpVUXRzE
Bearer 125956663|6x9nAcMIOVAAo1HyjQ4bzZCHlGie4ShSaxHDjqWZ
Bearer 125762035|QNYpH6Y4YmrW6ODF68FH3TJUT8KdD8IG24fWjXGt
Bearer 125760881|IWwl3zLSfvvHRbAHvE982hlIeGEW5sTYdTU2ARQQ
Bearer 125750605|fvuDBzijBoY3q3LzV03RYhrNQvqZ5tOQpoVxj9nr
Bearer 125337461|hwiGDcazSTE2oYEfWXeuwhkzg7Pq0L93JBq4kWaS
Bearer 125742859|3QJ9GfS2lUCjielHQn2wHoJuXlOxsk7jEeKkYZ8v
Bearer 125749370|FabrTW5EHVWn7WEQAQk1FcIPZSCtx3l6jCn34p5r
Bearer 125972516|qamXTWi88PSyocFqw0ULCzbzQaG1qF4yEEYJLaIh
Bearer 125973114|qSNuowWcvuJnXKXlx1JE5yyNLVELFN6Ff4gRQxIM
Bearer 125971296|Eg4Hf9VNgN6FEuZYT2aHBEnALairKqhAe2os38I5
Bearer 125961480|EOog24F8fCtTYKK5VoWfWRFG0cdmQ3dIXDynaQHk
Bearer 125748233|gc20Tr10WbNDi9OkHYuVzOw0DkPTRk0N45n7dJ7Z
Bearer 125958027|187pA2uHZx3YmKiP7AhHentD5zdPVc6NGJPG5tXr
Bearer 125858675|qlW1GsH4FEe5j9GRSU45uUJ2xy8b90BtMAWuuYB3
Bearer 125855856|2TrP68Pg0cFDzZBvz4DUODYqmCX0EpYW7sH11ZG8
Bearer 125855244|YnKZB4ouXjkZVHHqGhpIpBCBNzlzhdh7fbU2gIKC
Bearer 125856244|u91vJOWtHQXCc4ZalUYhRQZSVbsi3BRSHTyfpLQa
Bearer 125852726|FyKSZwCvOuWl00aUe5rvITuqc216luaok8abuxpz
Bearer 125854802|Cx5Gj9ewW3epTEYxpfISgIEjJjVD9NW3udHLmEgf
Bearer 125850811|l7XkYHhwtCSsIR3GNDEy0QaozO0hHjYLeVl4jpyu
Bearer 125761399|1G61MqGwdIaTRxjbI89zwyFHD4kAYUAUT0Zb1u9s
Bearer 125756391|uV7imdka3nM4XMcqYGgKORLJ5EHHcIIgMQxI16yz
Bearer 125753828|8JGBgWMrKIzUZ2e98zaYj0uy8YePUw1tlo8Hmg0K
Bearer 125741931|i6PXwYP23A0638Em3zF0m0d3aXV26bOWYsLyfUzN
Bearer 125753259|VNoYqvFHPjN5ug8M9MlXisAtzeNXkOJIqhjcHuHy
Bearer 125976933|doJmDvslQLZnQSCFrMkQADrDVuKAxH6gDGdXFbQu
Bearer 125959949|o19B52RDESJngoX3ffTZxGsfRgo46x5IJ3p8Ac2n
Bearer 125856687|ZYpO5AAgIX2R6PcCq5HFkK5oJrH8Gpl3u5pyg8dY
          </textarea>

        <label>üí¨ Comments (Ÿàÿßÿ≠ÿØ ÿ®ŸÉŸÑ ÿ≥ÿ∑ÿ±)</label>
        <textarea id="comments_${instanceId}" rows="4" placeholder="ŸÖŸÜŸàÿ± ÿßŸÑÿ®ÿ´\nÿ™ÿßÿ®ÿπŸÜŸä Ÿà ŸÑÿßŸäŸÉ üî•"></textarea>

        <label>üì∫ Channel Name</label>
        <input type="text" id="channel_${instanceId}" placeholder="username" value="FreeZe" />

        <label>‚è±Ô∏è Delay Between Comments (seconds)</label>
        <input type="number" id="interval_${instanceId}" placeholder="ŸÖÿ´ŸÑÿßŸã: 3" value="3" min="1" />

        <button class="startBtn" onclick="start(${instanceId})">‚ñ∂Ô∏è Start</button>
        <button class="stopBtn" onclick="stop(${instanceId})">‚õî Stop</button>

        <div id="log_${instanceId}" class="log"></div>
      `;
    }

    // ÿ•ŸÜÿ¥ÿßÿ° 3 ŸÜÿ≥ÿÆ
    createCommenter("commenter1", 1);
    createCommenter("commenter2", 2);
    createCommenter("commenter3", 3);

    const state = {
      1: { intervalId: null, isRunning: false, previousComments: {} },
      2: { intervalId: null, isRunning: false, previousComments: {} },
      3: { intervalId: null, isRunning: false, previousComments: {} }
    };

    function log(message, id) {
      const div = document.getElementById(`log_${id}`);
      div.innerHTML += `üìù ${message}<br>`;
      div.scrollTop = div.scrollHeight;
    }

    function getRandomComment(comments, token, id) {
      const prev = state[id].previousComments[token];
      let available = comments;
      if (prev) {
        available = comments.filter(c => c !== prev);
        if (available.length === 0) available = comments;
      }
      const comment = available[Math.floor(Math.random() * available.length)];
      state[id].previousComments[token] = comment;
      return comment;
    }

    async function getChatroomId(channel) {
      const res = await fetch(`https://kick.com/api/v2/channels/${channel}`);
      const data = await res.json();
      return data.chatroom.id;
    }

    async function start(id) {
      if (state[id].isRunning) return;
      state[id].isRunning = true;

      const tokens = document.getElementById(`tokens_${id}`).value.trim().split("\n").map(t => t.trim()).filter(Boolean);
      const comments = document.getElementById(`comments_${id}`).value.trim().split("\n").map(c => c.trim()).filter(Boolean);
      const channel = document.getElementById(`channel_${id}`).value.trim();
      let interval = parseInt(document.getElementById(`interval_${id}`).value);

      if (!channel || tokens.length === 0 || comments.length === 0 || isNaN(interval) || interval < 1) {
        alert(`(ŸÜÿ∏ÿßŸÖ ${id}) Ÿäÿ±ÿ¨Ÿâ ÿ™ÿπÿ®ÿ¶ÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ŸÇŸàŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠!`);
        state[id].isRunning = false;
        return;
      }

      interval = interval * 1000;

      try {
        const chatroomId = await getChatroomId(channel);
        log(`‚úÖ Chatroom ID: ${chatroomId}`, id);

        let index = 0;

        state[id].intervalId = setInterval(() => {
          if (!state[id].isRunning) return;

          const token = tokens[index % tokens.length];
          const comment = getRandomComment(comments, token, id);

          fetch("https://kick.com/api/v1/chat-messages", {
            method: "POST",
            headers: {
              Authorization: token,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              message: comment,
              chatroom_id: chatroomId,
            }),
          })
            .then((res) => {
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              log(`‚úÖ [${index + 1}] Sent: "${comment}"`, id);
            })
            .catch((err) => {
              log(`‚ùå Error: ${err.message}`, id);
            });

          index++;
        }, interval);
      } catch (error) {
        log(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® Chatroom ID: ${error.message}`, id);
        state[id].isRunning = false;
      }
    }

    function stop(id) {
      if (!state[id].isRunning) return;
      clearInterval(state[id].intervalId);
      state[id].isRunning = false;
      log("‚õî ÿ™ŸÖ ÿßŸÑÿ•ŸäŸÇÿßŸÅ.", id);
    }
  </script>
</body>
</html>
